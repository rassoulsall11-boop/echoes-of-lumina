<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>‚ú¶ GEMINI WORLD: PROCEDURAL AI ‚ú¶</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; }
        #hud { position: fixed; inset: 0; pointer-events: none; color: #00f2ff; padding: 20px; }
        .stat-bar { width: 200px; height: 10px; border: 1px solid #00f2ff; margin: 5px 0; position: relative; }
        .fill { height: 100%; background: #00f2ff; transition: width 0.2s; box-shadow: 0 0 10px #00f2ff; }
        #xp-bar { border-color: #ffd700; } #xp-fill { background: #ffd700; width: 0%; }
        .crosshair { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 20px; }
        #inventory { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; }
        .slot { width: 50px; height: 50px; border: 2px solid rgba(0,242,255,0.3); background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; font-size: 24px; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

<div id="hud">
    <div>SYSTEM STATUS: ONLINE</div>
    <div class="stat-bar"><div id="hp-fill" class="fill"></div></div>
    <div style="color: #ffd700; font-size: 12px; margin-top: 10px;">EXP LEVEL <span id="lvl-txt">1</span></div>
    <div class="stat-bar" id="xp-bar"><div id="xp-fill" class="fill"></div></div>
    <div id="msg" style="margin-top: 20px; font-size: 12px; opacity: 0.7;">Utilisez ZQSD pour marcher, E pour tirer</div>
</div>

<div class="crosshair">+</div>

<div id="inventory">
    <div class="slot" style="border-color: #00f2ff;">‚ùÑÔ∏è</div>
    <div class="slot">üõ°Ô∏è</div>
    <div class="slot">‚ö°</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, player, clock;
    let keys = {};
    let hp = 100, xp = 0, level = 1;
    let projectiles = [], enemies = [], chunks = [];
    const CHUNK_SIZE = 50;

    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x00050a, 0.05);
        
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x00050a);
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        // Joueur
        player = new THREE.Group();
        player.position.y = 2;
        scene.add(player);

        // Lumi√®re
        const light = new THREE.PointLight(0x00f2ff, 2, 50);
        player.add(light);
        scene.add(new THREE.AmbientLight(0x111111));

        // G√©n√©ration initiale
        generateChunk(0, 0);

        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if(e.code === 'KeyE') shoot();
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        animate();
    }

    // "IA" de g√©n√©ration proc√©durale simple
    function generateChunk(x, z) {
        const geo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, 20, 20);
        const pos = geo.attributes.position;
        
        // Simule une IA qui sculpte le terrain
        for(let i = 0; i < pos.count; i++) {
            let px = pos.getX(i) + x;
            let pz = pos.getY(i) + z;
            let h = Math.sin(px * 0.1) * Math.cos(pz * 0.1) * 3; // Algorithme de relief
            pos.setZ(i, h);
        }
        geo.computeVertexNormals();

        const mat = new THREE.MeshStandardMaterial({ 
            color: 0x001122, 
            wireframe: true,
            emissive: 0x002244
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = -Math.PI / 2;
        mesh.position.set(x, 0, z);
        scene.add(mesh);
        chunks.push(mesh);

        // Ajouter des ennemis al√©atoires dans ce chunk
        spawnEnemy(x, z);
    }

    function spawnEnemy(x, z) {
        const enemyGeo = new THREE.BoxGeometry(1, 1, 1);
        const enemyMat = new THREE.MeshBasicMaterial({ color: 0xff0033, wireframe: true });
        const enemy = new THREE.Mesh(enemyGeo, enemyMat);
        enemy.position.set(x + (Math.random()-0.5)*40, 1, z + (Math.random()-0.5)*40);
        scene.add(enemy);
        enemies.push(enemy);
    }

    function shoot() {
        const proj = new THREE.Mesh(
            new THREE.IcosahedronGeometry(0.2),
            new THREE.MeshBasicMaterial({ color: 0x00f2ff })
        );
        proj.position.copy(player.position);
        // Direction vers l'avant (simplifi√©e)
        const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
        proj.userData.velocity = dir.multiplyScalar(0.5);
        scene.add(proj);
        projectiles.push(proj);
    }

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        // Mouvement fluide
        if(keys['KeyW']) player.translateZ(-0.2);
        if(keys['KeyS']) player.translateZ(0.2);
        if(keys['KeyA']) player.rotation.y += 0.05;
        if(keys['KeyD']) player.rotation.y -= 0.05;

        // Mise √† jour projectiles
        projectiles.forEach((p, i) => {
            p.position.add(p.userData.velocity);
            // Collision Ennemis
            enemies.forEach((en, ei) => {
                if(p.position.distanceTo(en.position) < 1.5) {
                    scene.remove(en);
                    enemies.splice(ei, 1);
                    gainXP(20);
                }
            });
            if(p.position.length() > 100) { scene.remove(p); projectiles.splice(i, 1); }
        });

        // IA des Ennemis (suivent le joueur)
        enemies.forEach(en => {
            en.lookAt(player.position);
            en.translateZ(0.05);
            if(en.position.distanceTo(player.position) < 1) {
                hp -= 0.5;
                document.getElementById('hp-fill').style.width = hp + "%";
            }
        });

        // Cam√©ra suit le joueur √† la 3√®me personne
        const offset = new THREE.Vector3(0, 3, 6).applyQuaternion(player.quaternion);
        camera.position.copy(player.position).add(offset);
        camera.lookAt(player.position);

        renderer.render(scene, camera);
    }

    function gainXP(amt) {
        xp += amt;
        if(xp >= 100) {
            xp = 0; level++;
            document.getElementById('lvl-txt').innerText = level;
        }
        document.getElementById('xp-fill').style.width = xp + "%";
    }

    init();
</script>
</body>
</html>
