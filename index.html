<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‚ú¶ GEMINI WORLD - OPTIMIZED ‚ú¶</title>
    <style>
        :root { --neon: #00f2ff; --dark-bg: #00040a; }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Roboto, sans-serif; cursor: crosshair; }
        
        /* UI Ultra-l√©g√®re pour booster les FPS */
        #ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 10; padding: 20px; }
        
        .stats-panel { width: 250px; }
        .bar-container { 
            height: 12px; background: rgba(0,0,0,0.5); border: 1px solid var(--neon); 
            border-radius: 6px; overflow: hidden; margin-bottom: 10px; box-shadow: 0 0 10px rgba(0,242,255,0.2);
        }
        .bar-fill { height: 100%; width: 100%; background: var(--neon); transition: width 0.2s; }
        
        .skill-tray { position: absolute; bottom: 30px; right: 30px; display: flex; gap: 10px; pointer-events: auto; }
        .skill-btn { 
            width: 60px; height: 60px; border-radius: 12px; border: 1px solid var(--neon);
            background: rgba(0,20,40,0.8); color: white; cursor: pointer; display: flex;
            align-items: center; justify-content: center; font-size: 20px;
        }

        #loading-screen {
            position: fixed; inset: 0; background: var(--dark-bg);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; transition: 0.5s;
        }
        .loader { width: 50px; height: 50px; border: 3px solid #111; border-top: 3px solid var(--neon); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="loading-screen">
    <div class="loader"></div>
    <h1 style="color: var(--neon); margin-top: 20px; font-family: sans-serif; letter-spacing: 5px;">INITIALISATION</h1>
</div>

<div id="ui-layer">
    <div class="stats-panel">
        <div style="color: var(--neon); font-size: 10px; margin-bottom: 4px;">SYSTEM ENERGY</div>
        <div class="bar-container"><div id="energy-fill" class="bar-fill"></div></div>
        <div style="color: #ffaa00; font-size: 10px; margin-bottom: 4px;">STAMINA</div>
        <div class="bar-container"><div id="stamina-fill" class="bar-fill" style="background: #ffaa00;"></div></div>
    </div>

    <div class="skill-tray">
        <div class="skill-btn" onclick="triggerIce()">‚ùÑÔ∏è</div>
        <div class="skill-btn" onclick="triggerPhase()">üëÅÔ∏è</div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, player, clock;
    let energy = 100, stamina = 100;
    let keys = {};

    // 1. Initialisation de la Sc√®ne
    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x00040a, 10, 50);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limite le pixel ratio pour mobile
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        // Lumi√®res optimis√©es (Seulement 2 lumi√®res max)
        const sun = new THREE.DirectionalLight(0x00f2ff, 1);
        sun.position.set(5, 10, 7);
        scene.add(sun);
        scene.add(new THREE.AmbientLight(0x404040, 0.5));

        createWorld();
        createPlayer();
        
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        setTimeout(() => document.getElementById('loading-screen').style.opacity = 0, 1000);
        animate();
    }

    // 2. Cr√©ation du Terrain (Utilisation d'une seule g√©om√©trie pour performance)
    function createWorld() {
        const grid = new THREE.GridHelper(200, 40, 0x00f2ff, 0x001122);
        scene.add(grid);

        // Sol solide simplifi√©
        const groundGeo = new THREE.PlaneGeometry(200, 200);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x00040a });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
        
        // Cristaux instanci√©s (Optionnel pour perf, ici simple mesh)
        for(let i=0; i<30; i++) {
            const crysGeo = new THREE.OctahedronGeometry(Math.random() * 0.5 + 0.2);
            const crysMat = new THREE.MeshBasicMaterial({ color: 0x00f2ff, wireframe: true });
            const crystal = new THREE.Mesh(crysGeo, crysMat);
            crystal.position.set(Math.random()*100-50, 0.5, Math.random()*100-50);
            scene.add(crystal);
        }
    }

    // 3. Cr√©ation du Personnage (Simple & Efficace)
    function createPlayer() {
        player = new THREE.Group();
        const body = new THREE.Mesh(
            new THREE.BoxGeometry(1, 2, 1),
            new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x00f2ff, emissiveIntensity: 0.5 })
        );
        body.position.y = 1;
        player.add(body);
        scene.add(player);
    }

    // 4. Boucle de Rendu (Optimis√©e)
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        // D√©placements
        const speed = keys['ShiftLeft'] ? 0.3 : 0.15;
        if (keys['KeyW']) player.position.z -= speed;
        if (keys['KeyS']) player.position.z += speed;
        if (keys['KeyA']) player.position.x -= speed;
        if (keys['KeyD']) player.position.x += speed;

        // Mise √† jour Cam√©ra (Smooth Follow)
        camera.position.lerp(new THREE.Vector3(player.position.x, player.position.y + 5, player.position.z + 10), 0.1);
        camera.lookAt(player.position);

        // Gestion √ânergie
        if (keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD']) {
            stamina = Math.max(0, stamina - 0.1);
        } else {
            stamina = Math.min(100, stamina + 0.2);
        }
        
        updateUI();
        renderer.render(scene, camera);
    }

    function updateUI() {
        document.getElementById('stamina-fill').style.width = stamina + "%";
        document.getElementById('energy-fill').style.width = energy + "%";
    }

    // Comp√©tences
    function triggerIce() {
        if(energy < 20) return;
        energy -= 20;
        const ice = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshBasicMaterial({ color: 0x00f2ff, transparent: true, opacity: 0.6 }));
        ice.position.copy(player.position);
        scene.add(ice);
        setTimeout(() => scene.remove(ice), 2000);
    }

    function triggerPhase() {
        player.children[0].material.opacity = 0.3;
        player.children[0].material.transparent = true;
        setTimeout(() => {
            player.children[0].material.opacity = 1;
        }, 2000);
    }

    init();

    // Redimensionnement
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
