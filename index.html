```html
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>KINETIC PHANTOM // NEXUS ARCHITECT</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #00ffcc;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
            border: 2px solid #333;
        }

        canvas {
            display: block;
            background-color: #2b2b2b; /* Sol gris foncé */
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
        }

        .status-text {
            font-size: 14px;
            text-shadow: 1px 1px 0 #000;
        }

        #gameOverScreen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        h1 { margin: 0 0 20px 0; color: #ff3333; text-transform: uppercase; letter-spacing: 5px; }
        .win { color: #00ffcc !important; }
        
        button {
            background: transparent;
            border: 1px solid #00ffcc;
            color: #00ffcc;
            padding: 10px 20px;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.3s;
        }
        button:hover { background: #00ffcc; color: #000; }
    </style>
</head>
<body>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="ui-layer">
            <div class="status-text">ÉTAT DU SYSTÈME: <span id="systemState">NOMINAL</span></div>
            <div class="status-text">ÉNERGIE CINÉTIQUE: <span id="kineticStatus">INACTIF</span></div>
        </div>

        <div id="gameOverScreen">
            <h1 id="endTitle">ÉCHEC CRITIQUE</h1>
            <p id="endReason" style="color: #fff; margin-bottom: 20px;"></p>
            <button onclick="nexusGame.reset()">RÉINITIALISER LA SIMULATION</button>
        </div>
    </div>

<script>
/**
 * NEXUS ARCHITECT v2.0
 * Module: Core Game Logic
 */

const CONFIG = {
    PLAYER_SPEED: 4,
    PLAYER_SIZE: 20,
    ENERGY_MAX: 100,
    ENERGY_DRAIN: 1.5,       // Coût par frame du mode Travers
    ENERGY_RECHARGE: 0.8,    // Gain par frame si mouvement
    COLOR_WALL: '#000000',
    COLOR_PLAYER_NORMAL: '#00ff00',
    COLOR_PLAYER_PHASE: 'rgba(0, 150, 255, 0.4)', // Bleu transparent
    COLOR_PORTAL: '#9900ff'
};

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Input State
        this.keys = {
            ArrowUp: false, ArrowDown: false, 
            ArrowLeft: false, ArrowRight: false, 
            w: false, s: false, a: false, d: false,
            " ": false // Espace
        };

        // Game State
        this.isRunning = true;
        this.player = {
            x: 50, y: 50,
            w: CONFIG.PLAYER_SIZE, h: CONFIG.PLAYER_SIZE,
            energy: CONFIG.ENERGY_MAX,
            isPhasing: false
        };

        // Level Design (Murs noirs)
        this.walls = [
            {x: 150, y: 0, w: 50, h: 400},
            {x: 150, y: 500, w: 50, h: 100},
            {x: 350, y: 200, w: 50, h: 400},
            {x: 350, y: 0, w: 50, h: 100},
            {x: 550, y: 0, w: 50, h: 500}, // Mur presque complet
            {x: 0, y: 0, w: 800, h: 10},   // Bordures
            {x: 0, y: 590, w: 800, h: 10},
            {x: 0, y: 0, w: 10, h: 600},
            {x: 790, y: 0, w: 10, h: 600}
        ];

        this.portal = { x: 700, y: 520, w: 40, h: 40 };

        // Bindings
        window.addEventListener('keydown', e => this.handleKey(e, true));
        window.addEventListener('keyup', e => this.handleKey(e, false));

        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    handleKey(e, state) {
        if(this.keys.hasOwnProperty(e.key) || e.key === " ") {
            this.keys[e.key] = state;
        }
    }

    reset() {
        this.player.x = 50;
        this.player.y = 50;
        this.player.energy = CONFIG.ENERGY_MAX;
        this.player.isPhasing = false;
        this.isRunning = true;
        document.getElementById('gameOverScreen').style.display = 'none';
        this.loop();
    }

    update() {
        if (!this.isRunning) return;

        // 1. Gestion du mode Travers (Phasing)
        // Activation seulement si Espace appuyé ET énergie > 0
        if (this.keys[" "] && this.player.energy > 0) {
            this.player.isPhasing = true;
            this.player.energy -= CONFIG.ENERGY_DRAIN;
        } else {
            this.player.isPhasing = false;
        }

        // Clamp Energy
        if (this.player.energy < 0) this.player.energy = 0;
        if (this.player.energy > CONFIG.ENERGY_MAX) this.player.energy = CONFIG.ENERGY_MAX;

        // 2. Mouvement
        let dx = 0;
        let dy = 0;
        if (this.keys.ArrowUp || this.keys.w) dy = -CONFIG.PLAYER_SPEED;
        if (this.keys.ArrowDown || this.keys.s) dy = CONFIG.PLAYER_SPEED;
        if (this.keys.ArrowLeft || this.keys.a) dx = -CONFIG.PLAYER_SPEED;
        if (this.keys.ArrowRight || this.keys.d) dx = CONFIG.PLAYER_SPEED;

        // Normalisation diagonale
        if (dx !== 0 && dy !== 0) {
            dx *= 0.707;
            dy *= 0.707;
        }

        // 3. Recharge Cinétique
        // On ne recharge que si on bouge ET qu'on n'est pas en mode Travers
        const isMoving = dx !== 0 || dy !== 0;
        if (isMoving && !this.player.isPhasing) {
            this.player.energy += CONFIG.ENERGY_RECHARGE;
            document.getElementById('kineticStatus').textContent = "CHARGE EN COURS...";
            document.getElementById('kineticStatus').style.color = "#00ff00";
        } else if (this.player.isPhasing) {
            document.getElementById('kineticStatus').textContent = "DRAINAGE RAPIDE";
            document.getElementById('kineticStatus').style.color = "#ff0000";
        } else {
            document.getElementById('kineticStatus').textContent = "STABLE";
            document.getElementById('kineticStatus').style.color = "#00ffcc";
        }

        // 4. Physique prédictive (Collision Murs)
        let nextX = this.player.x + dx;
        let nextY = this.player.y + dy;

        // Si on n'est PAS en phasing, on vérifie les collisions
        if (!this.player.isPhasing) {
            // Check X
            if (!this.checkCollision(nextX, this.player.y)) {
                this.player.x = nextX;
            }
            // Check Y
            if (!this.checkCollision(this.player.x, nextY)) {
                this.player.y = nextY;
            }
        } else {
            // Mode Travers : On bouge librement (sauf limites canvas)
            this.player.x = nextX;
            this.player.y = nextY;
            
            // Contraindre aux limites du canvas (on ne traverse pas la réalité)
            this.player.x = Math.max(0, Math.min(this.canvas.width - this.player.w, this.player.x));
            this.player.y = Math.max(0, Math.min(this.canvas.height - this.player.h, this.player.y));
        }

        // 5. Conditions de Victoire / Défaite
        
        // Victoire : Collision Portail
        if (this.rectIntersect(this.player.x, this.player.y, this.player.w, this.player.h,
                               this.portal.x, this.portal.y, this.portal.w, this.portal.h)) {
            this.endGame(true, "Extraction Réussie.");
            return;
        }

        // Défaite Critique : Matérialisation dans un mur
        // Si le joueur n'est plus en phasing (énergie vide ou touche relâchée)
        // et qu'il est DANS un mur.
        if (!this.player.isPhasing && this.checkCollision(this.player.x, this.player.y)) {
            this.endGame(false, "ANOMALIE : Matérialisation à l'intérieur d'un solide. Structure moléculaire détruite.");
        }
        
        // Update UI
        document.getElementById('systemState').textContent = this.player.isPhasing ? "SPECTRAL (TRAVERS)" : "SOLIDE";
        document.getElementById('systemState').style.color = this.player.isPhasing ? "#0096ff" : "#00ffcc";
    }

    // Retourne true si collision avec un mur
    checkCollision(x, y) {
        for (let wall of this.walls) {
            if (this.rectIntersect(x, y, this.player.w, this.player.h, wall.x, wall.y, wall.w, wall.h)) {
                return true;
            }
        }
        return false;
    }

    rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
    }

    draw() {
        // Clear
        this.ctx.fillStyle = '#2b2b2b';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw Walls
        this.ctx.fillStyle = CONFIG.COLOR_WALL;
        for (let wall of this.walls) {
            this.ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
        }

        // Draw Portal
        this.ctx.fillStyle = CONFIG.COLOR_PORTAL;
        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = CONFIG.COLOR_PORTAL;
        this.ctx.fillRect(this.portal.x, this.portal.y, this.portal.w, this.portal.h);
        this.ctx.shadowBlur = 0;

        // Draw Player
        this.ctx.fillStyle = this.player.isPhasing ? CONFIG.COLOR_PLAYER_PHASE : CONFIG.COLOR_PLAYER_NORMAL;
        if (this.player.isPhasing) {
             // Effet visuel spectral (stroke)
             this.ctx.strokeStyle = '#00ffff';
             this.ctx.lineWidth = 2;
             this.ctx.strokeRect(this.player.x, this.player.y, this.player.w, this.player.h);
        }
        this.ctx.fillRect(this.player.x, this.player.y, this.player.w, this.player.h);

        // Draw Energy Bar (HUD)
        this.drawHUD();
    }

    drawHUD() {
        const barW = 200;
        const barH = 15;
        const x = 10;
        const y = this.canvas.height - 30;

        // Fond barre
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(x, y, barW, barH);

        // Niveau énergie
        const pct = this.player.energy / CONFIG.ENERGY_MAX;
        
        // Couleur dynamique (Vert -> Rouge)
        const r = Math.floor(255 * (1 - pct));
        const g = Math.floor(255 * pct);
        this.ctx.fillStyle = `rgb(${r}, ${g}, 0)`;
        
        this.ctx.fillRect(x, y, barW * pct, barH);

        // Bordure HUD
        this.ctx.strokeStyle = '#fff';
        this.ctx.lineWidth = 1;
        this.ctx.strokeRect(x, y, barW, barH);
        
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '12px Courier New';
        this.ctx.fillText("BATTERIE", x, y - 5);
    }

    endGame(win, reason) {
        this.isRunning = false;
        const screen = document.getElementById('gameOverScreen');
        const title = document.getElementById('endTitle');
        const msg = document.getElementById('endReason');
        
        screen.style.display = 'flex';
        msg.textContent = reason;

        if (win) {
            title.textContent = "MISSION ACCOMPLIE";
            title.className = "win";
        } else {
            title.textContent = "SIGNAL PERDU";
            title.className = "";
        }
    }

    loop() {
        if (this.isRunning) {
            this.update();
            this.draw();
            requestAnimationFrame(this.loop);
        }
    }
}

// Initialisation du système
const nexusGame = new Game();

</script>
</body>
</html>
```

### Analyse Technique des Fonctionnalités
