<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ECHOES OF LUMINA - PAROXYSM</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root { --neon: #00f2ff; --gold: #ffd700; --dark: #020205; }
        body { margin: 0; background: var(--dark); color: white; font-family: 'Orbitron', sans-serif; overflow: hidden; touch-action: none; }
        
        /* HUD Style RPG */
        #hud { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); z-index: 100; pointer-events: none; width: 300px; text-align: center; }
        .energy-container { width: 100%; height: 8px; background: rgba(0,0,0,0.5); border: 1px solid rgba(0,242,255,0.3); border-radius: 4px; overflow: hidden; box-shadow: 0 0 15px rgba(0,242,255,0.2); }
        #energy-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #00f2ff, #0072ff); transition: width 0.3s; }
        .level-tag { font-size: 10px; color: var(--neon); letter-spacing: 2px; margin-bottom: 5px; }

        /* BOUTONS D'ACTION */
        .action-tray { position: fixed; right: 20px; bottom: 40px; display: flex; flex-direction: column; gap: 20px; z-index: 200; }
        .skill-btn { width: 70px; height: 70px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.6); backdrop-filter: blur(5px); color: white; font-size: 10px; cursor: pointer; transition: 0.2s; }
        .skill-btn:active { transform: scale(0.9); border-color: var(--neon); box-shadow: 0 0 20px var(--neon); }

        /* JOYSTICK */
        #joystick-zone { position: fixed; left: 40px; bottom: 40px; width: 150px; height: 150px; z-index: 200; }
        #joy-base { width: 100%; height: 100%; background: rgba(255,255,255,0.05); border-radius: 50%; border: 1px solid rgba(255,255,255,0.1); position: relative; }
        #joy-stick { width: 60px; height: 60px; background: white; border-radius: 50%; position: absolute; left: 45px; top: 45px; opacity: 0.8; box-shadow: 0 0 20px rgba(255,255,255,0.3); }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.min.js"></script>
</head>
<body>

<div id="hud">
    <div class="level-tag">PLAYER 09 - GEMINI PROTOCOL</div>
    <div class="energy-container"><div id="energy-bar"></div></div>
</div>

<div id="joystick-zone"><div id="joy-base"><div id="joy-stick"></div></div></div>

<div class="action-tray">
    <button class="skill-btn" onclick="creerGlace()">CRÉATION<br>GLACE</button>
    <button class="skill-btn" onclick="toggleIntangible()">TRAVERS</button>
</div>

<script>
    let scene, camera, renderer, clock, player;
    let moveDir = { x: 0, z: 0 };
    let energy = 100;
    let isMoving = false;

    // --- INITIALISATION ---
    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020205);
        scene.fog = new THREE.FogExp2(0x020205, 0.015);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lumière type "Genshin" (Nuit étoilée)
        const ambient = new THREE.AmbientLight(0x4040ff, 0.5);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(50, 100, 50);
        scene.add(sun);

        // Sol infini avec grille lumineuse
        const floorGeo = new THREE.PlaneGeometry(2000, 2000, 50, 50);
        const floorMat = new THREE.MeshPhongMaterial({ color: 0x050510, wireframe: false, shininess: 100 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Création du Personnage (Modèle articulé)
        player = new THREE.Group();
        
        // Corps
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.5), new THREE.MeshPhongMaterial({color: 0xffffff}));
        torso.position.y = 1.6;
        player.add(torso);

        // Tête
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16), new THREE.MeshPhongMaterial({color: 0xffffff}));
        head.position.y = 2.4;
        player.add(head);

        // Jambes
        const legGeo = new THREE.BoxGeometry(0.3, 1, 0.3);
        player.leftLeg = new THREE.Mesh(legGeo, new THREE.MeshPhongMaterial({color: 0x00f2ff}));
        player.rightLeg = new THREE.Mesh(legGeo, new THREE.MeshPhongMaterial({color: 0x00f2ff}));
        player.leftLeg.position.set(-0.25, 0.5, 0);
        player.rightLeg.position.set(0.25, 0.5, 0);
        player.add(player.leftLeg, player.rightLeg);

        scene.add(player);
        clock = new THREE.Clock();

        setupControls();
        animate();
    }

    // --- CONTROLES ---
    function setupControls() {
        const base = document.getElementById('joy-base');
        const stick = document.getElementById('joy-stick');
        
        base.addEventListener('touchmove', (e) => {
            const r = base.getBoundingClientRect();
            const touch = e.touches[0];
            let dx = touch.clientX - (r.left + r.width/2);
            let dy = touch.clientY - (r.top + r.height/2);
            const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 50);
            const angle = Math.atan2(dy, dx);
            
            stick.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
            
            moveDir.x = Math.cos(angle) * (dist/50);
            moveDir.z = Math.sin(angle) * (dist/50);
            isMoving = dist > 5;

            player.rotation.y = -angle - Math.PI/2;
        });

        base.addEventListener('touchend', () => {
            stick.style.transform = 'translate(0,0)';
            moveDir = {x: 0, z: 0};
            isMoving = false;
        });
    }

    function creerGlace() {
        if(energy < 20) return;
        energy -= 20;
        
        const ice = new THREE.Mesh(
            new THREE.IcosahedronGeometry(1.5, 0),
            new THREE.MeshPhongMaterial({ color: 0x00f2ff, transparent: true, opacity: 0.8, flatShading: true })
        );
        ice.position.set(player.position.x + moveDir.x*3, 0.75, player.position.z + moveDir.z*3);
        scene.add(ice);
        
        // Petite animation d'apparition
        ice.scale.set(0,0,0);
        let s = 0;
        const grow = setInterval(() => {
            s += 0.2;
            ice.scale.set(s,s,s);
            if(s >= 1) clearInterval(grow);
        }, 30);
    }

    function toggleIntangible() {
        player.traverse(child => {
            if(child.isMesh) {
                child.material.transparent = true;
                child.material.opacity = (child.material.opacity === 0.3) ? 1 : 0.3;
            }
        });
    }

    // --- BOUCLE DE JEU ---
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        if(isMoving) {
            player.position.x += moveDir.x * 0.15;
            player.position.z += moveDir.z * 0.15;
            
            // Animation de marche
            player.leftLeg.rotation.x = Math.sin(time * 10) * 0.5;
            player.rightLeg.rotation.x = -Math.sin(time * 10) * 0.5;
            
            energy -= 0.05;
            document.getElementById('energy-bar').style.width = energy + "%";
        } else {
            // Animation "Idle" (respiration)
            player.leftLeg.rotation.x = 0;
            player.rightLeg.rotation.x = 0;
            player.position.y = Math.sin(time * 2) * 0.05;
        }

        // Caméra 3ème personne fluide
        const camOffset = new THREE.Vector3(0, 5, 10);
        camOffset.applyQuaternion(player.quaternion);
        camera.position.lerp(player.position.clone().add(new THREE.Vector3(0, 5, 8)), 0.1);
        camera.lookAt(player.position.x, player.position.y + 1, player.position.z);

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
</script>
</body>
</html>
